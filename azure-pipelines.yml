#
# CI triggers
#
trigger: none

pr:
  branches:
    include:
      - main
  paths:
    include:
      - build
      - src

#
# Version and jobs
#
variables:
  buildVersionMajor: 0
  buildVersionMinor: 1
  buildVersionRevision: $[counter(format('{0}.{1}', variables['buildVersionMajor'], variables['buildVersionMinor']), 0)]

# Run
name: '$(buildVersionMajor).$(buildVersionMinor).$(buildVersionRevision)'

stages:
- stage: Build
  jobs:
  - job: Build
    #
    # Build flavors
    #
    strategy:
      matrix:
        windows-x86:
          poolName: Azure Pipelines
          imageName: 'windows-latest'
          rustup_toolchain: stable
          target: i686-pc-windows-msvc
          target_short: windows.x86
          is_cross_compile: true
          gcc_prefix:
          gcc_suffix:
        windows-x64:
          poolName: Azure Pipelines
          imageName: 'windows-latest'
          rustup_toolchain: stable
          target: x86_64-pc-windows-msvc
          target_short: windows.x64
          is_cross_compile: false
          gcc_prefix:
          gcc_suffix:
        windows-arm64:
          poolName: Azure Pipelines
          imageName: 'windows-latest'
          rustup_toolchain: stable
          target: aarch64-pc-windows-msvc
          target_short: windows.arm64
          is_cross_compile: true
          gcc_prefix:
          gcc_suffix:
        linux-x86:
          poolName: Azure Pipelines
          imageName: 'ubuntu-latest'
          rustup_toolchain: stable
          target: i686-unknown-linux-gnu
          target_short: linux.x86
          is_cross_compile: true
          gcc_prefix: i686-linux-gnu-
          gcc_suffix: -i686-linux-gnu
        linux-x64:
          poolName: Azure Pipelines
          imageName: 'ubuntu-latest'
          rustup_toolchain: stable
          target: x86_64-unknown-linux-gnu
          target_short: linux.x64
          is_cross_compile: false
          gcc_prefix:
          gcc_suffix:
        linux-arm:
          poolName: Azure Pipelines
          imageName: 'ubuntu-latest'
          rustup_toolchain: stable
          target: arm-unknown-linux-gnueabi
          target_short: linux.arm
          is_cross_compile: true
          gcc_prefix: arm-linux-gnueabi-
          gcc_suffix: -arm-linux-gnueabi
        linux-arm64:
          poolName: Azure Pipelines
          imageName: 'ubuntu-latest'
          rustup_toolchain: stable
          target: aarch64-unknown-linux-gnu
          target_short: linux.arm64
          is_cross_compile: true
          gcc_prefix: aarch64-linux-gnu-
          gcc_suffix: -aarch64-linux-gnu
        macos-x64:
          poolName: Azure Pipelines
          imageName: 'macos-latest'
          rustup_toolchain: stable
          target: x86_64-apple-darwin
          target_short: macos.x64
          is_cross_compile: false
          gcc_prefix:
          gcc_suffix:

    pool:
      name: $(poolName)
      vmImage: $(imageName)

    workspace:
      clean: all

    steps:
    #
    # Force cleanup.
    # Self-hosted agents must be cleaned up, otherwise it might carry the previous result to the latest build.
    # https://docs.microsoft.com/en-us/azure/devops/pipelines/repos/pipeline-options-for-git?view=azure-devops&tabs=yaml#clean-the-local-repo-on-the-agent
    #
    - checkout: self
      clean: true

    #
    # Environment variable updates
    #
    - bash: |
        BUILD_BRANCH_NAME="$(Build.SourceBranch)"
        BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME#refs/heads/}
        BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME#refs/tags/}
        BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME//\//_}
        echo "##vso[task.setvariable variable=build.branch_name]$BUILD_BRANCH_NAME"
        echo "Updated build.branch_name to $BUILD_BRANCH_NAME"

        BUILD_VERSION=$(buildVersionMajor).$(buildVersionMinor).$(buildVersionRevision)
        echo "##vso[task.setvariable variable=build.version]$BUILD_VERSION"
        echo "Updated build.version to $BUILD_VERSION"

        BUILD_TAG=$BUILD_VERSION.$BUILD_BRANCH_NAME
        echo "##vso[task.setvariable variable=build.tag]$BUILD_TAG"
        echo "Updated build.tag to $BUILD_TAG"
      displayName: Update build environment variables

    #
    # Update build environment
    #
    - bash: |
        rustup default $RUSTUP_TOOLCHAIN
        rustup update $RUSTUP_TOOLCHAIN
      displayName: rustup update default toolchain

    - script: rustup target install $(TARGET)
      displayName: rustup install target

    - bash: |
        sudo apt install gcc make gcc$(GCC_SUFFIX) binutils$(GCC_SUFFIX)
      displayName: Install build tools for cross build
      condition: and(succeeded(), ne(variables['gcc_suffix'], ''))

    #
    # Update version files and pack all source code for crate publishing
    #
    - bash: |
        sed -i 's/^version = "0.1.0"$/version = "$(build.version)"/' Cargo.toml
      displayName: Update crate version
      condition: and(succeeded(), ne(variables['target'], 'x86_64-apple-darwin'))

    - bash: |
        sed -i.bak 's/^version = "0.1.0"$/version = "$(build.version)"/' Cargo.toml
      displayName: Update crate version
      condition: and(succeeded(), eq(variables['target'], 'x86_64-apple-darwin'))

    - task: ArchiveFiles@2
      displayName: Pack source folder for crate publishing
      condition: and(succeeded(), eq(variables['target'], 'x86_64-unknown-linux-gnu'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)'
        archiveType: '7z'
        archiveFile: '$(Build.ArtifactStagingDirectory)/crate/rnp.source.7z'

    - task: CopyFiles@2
      displayName: Copy chocolatey template to output
      condition: and(succeeded(), eq(variables['target'], 'x86_64-unknown-linux-gnu'))
      inputs:
        sourceFolder: '$(Build.SourcesDirectory)/build/templates/chocolatey'
        targetFolder: '$(Build.ArtifactStagingDirectory)/chocolatey'

    #
    # Build
    #
    - script: cargo build --release --all --target $(TARGET)
      displayName: Cargo build

    - bash: |
        $(GCC_PREFIX)objcopy --only-keep-debug rnp rnp.symbols
        $(GCC_PREFIX)strip --strip-debug --strip-unneeded -p rnp
        $(GCC_PREFIX)objcopy --add-gnu-debuglink=rnp.symbols rnp
      displayName: Generate GCC symbol files
      condition: and(succeeded(), startsWith(variables['target_short'], 'linux.'))
      workingDirectory: $(Build.SourcesDirectory)/target/$(TARGET)/release

    - bash: |
        brew install binutils
        /usr/local/opt/binutils/bin/gobjcopy --only-keep-debug rnp rnp.symbols
        strip -S rnp
        /usr/local/opt/binutils/bin/gobjcopy --add-gnu-debuglink=rnp.symbols rnp
      displayName: Generate GCC symbol files
      condition: and(succeeded(), startsWith(variables['target_short'], 'macos.'))
      workingDirectory: $(Build.SourcesDirectory)/target/$(TARGET)/release

    #
    # Running all tests
    #
    - bash: RUST_BACKTRACE=1 cargo test --release --all --target $(TARGET)
      displayName: Cargo test
      condition: and(succeeded(), eq(variables['is_cross_compile'], false))

    #
    # Publish files for release
    #
    - task: CopyFiles@2
      displayName: Copy binary to output
      inputs:
        sourceFolder: '$(Build.SourcesDirectory)/target/$(TARGET)/release'
        contents: |
          rnp*
          !rnp.pdb
          !rnp.symbols
          !rnp.d
        targetFolder: '$(Build.ArtifactStagingDirectory)/bin'

    - task: CopyFiles@2
      displayName: Copy docs to output
      inputs:
        sourceFolder: '$(Build.SourcesDirectory)'
        contents: |
          README.md
          LICENSE.txt
        targetFolder: '$(Build.ArtifactStagingDirectory)/bin'

    - task: CopyFiles@2
      displayName: Copy symbols to output
      inputs:
        sourceFolder: '$(Build.SourcesDirectory)/target/$(TARGET)/release'
        contents: |
          rnp.pdb
          rnp.symbols
        targetFolder: '$(Build.ArtifactStagingDirectory)/symbols'

    - task: CopyFiles@2
      displayName: Copy package template to output
      condition: and(succeeded(), eq(variables['target'], 'x86_64-unknown-linux-gnu'))
      inputs:
        sourceFolder: '$(Build.SourcesDirectory)/build/templates'
        targetFolder: '$(Build.ArtifactStagingDirectory)/templates'

    #
    # Publish all pipeline artifacts
    #
    - task: PublishPipelineArtifact@1
      displayName: Publish pipeline artifact
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'

- stage: Pack
  jobs:
  - job: Pack
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))

    pool:
      name: Azure Pipelines
      vmImage: 'windows-latest'

    workspace:
      clean: all

    steps:
      - checkout: none

      - task: DownloadPipelineArtifact@2
        displayName: 'Download Pipeline Artifact'
        inputs:
          targetPath: '$(System.DefaultWorkingDirectory)/r12f.rnp'

      - bash: |
          BUILD_BRANCH_NAME="$(Build.SourceBranch)"
          BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME#refs/heads/}
          BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME#refs/tags/}
          BUILD_BRANCH_NAME=${BUILD_BRANCH_NAME//\//_}
          echo "##vso[task.setvariable variable=build.branch_name]$BUILD_BRANCH_NAME"
          echo "Updated build.branch_name to $BUILD_BRANCH_NAME"

          BUILD_VERSION=$(buildVersionMajor).$(buildVersionMinor).$(buildVersionRevision)
          echo "##vso[task.setvariable variable=build.version]$BUILD_VERSION"
          echo "Updated build.version to $BUILD_VERSION"

          BUILD_TAG=$BUILD_VERSION.$BUILD_BRANCH_NAME
          echo "##vso[task.setvariable variable=build.tag]$BUILD_TAG"
          echo "Updated build.tag to $BUILD_TAG"
        displayName: 'Set environment variables'

      - powershell: |
          function EvaluateTemplate($template) {
              return $template.Replace("{build_branch_name}", "$(build.branch_name)").Replace("{build_tag}", "$(build.tag)").Replace("{version}", "$(Build.BuildNumber)").Replace("{target_short}", $flavor).Replace("{target}", $target)
          }

          function EvaluateTemplateFile($templateFile, $targetFile) {
              $templateFileContent = gc $templateFile;
              $targetFileContent = EvaluateTemplate $templateFileContent

              $utf8NoBom = New-Object System.Text.UTF8Encoding $False
              [System.IO.File]::WriteAllLines($targetFile, $targetFileContent, $utf8NoBom)
          }

          function EvaluateTemplateFileWithFileHash($templateFile, $targetFile, $fileHashs) {
              $templateFileContent = gc $templateFile;
              $targetFileContent = EvaluateTemplate $templateFileContent
              $targetFileContent = $targetFileContent.Replace("{rnp_bin_hash_x86}", $fileHashs.BinX86).Replace("{rnp_bin_hash_x64}", $fileHashs.BinX64).Replace("{package_zip_hash_x86}", $fileHashs.ZipX86).Replace("{package_zip_hash_x64}", $fileHashs.ZipX64);

              $utf8NoBom = New-Object System.Text.UTF8Encoding $False
              [System.IO.File]::WriteAllLines($targetFile, $targetFileContent, $utf8NoBom)
          }

          New-Item -ItemType Directory -Path ".\Releases\Crate.io"
          New-Item -ItemType Directory -Path ".\Releases\GithubReleases"
          New-Item -ItemType Directory -Path ".\Releases\NugetPackages"
          New-Item -ItemType Directory -Path ".\Releases\Chocolatey"
          New-Item -ItemType Directory -Path ".\Staging\Chocolatey"
          New-Item -ItemType Directory -Path ".\Staging\Chocolatey\tools"

          $flavors= @{
              "windows.x86" = @{"Root"="Build.Build.windowsx86"; "Target"="i686-pc-windows-msvc"};
              "windows.x64" = @{"Root"="Build.Build.windowsx64";"Target"="x86_64-pc-windows-msvc"};
              "windows.arm64" = @{"Root"="Build.Build.windowsarm64";"Target"="aarch64-pc-windows-msvc"};
              "linux.x86" = @{"Root"="Build.Build.linuxx86"; "Target"="i686-unknown-linux-gnu"};
              "linux.x64" = @{"Root"="Build.Build.linuxx64";"Target"="x86_64-unknown-linux-gnu"};
              "linux.arm" = @{"Root"="Build.Build.linuxarm";"Target"="arm-unknown-linux-gnueabi"};
              "linux.arm64" = @{"Root"="Build.Build.linuxarm64";"Target"="aarch64-unknown-linux-gnu"};
              "macos.x64" = @{"Root"="Build.Build.macosx64";"Target"="x86_64-apple-darwin"};
          }

          $flavors.GetEnumerator() | ForEach-Object {
              $flavor = $_.Name
              $root = $_.Value["Root"]
              $target = $_.Value["Target"]
              Write-Host "Processing build: Flavor = $flavor, Root = $root, Target = $target"

              # Create zip for github release
              $zipFilePath = ".\Releases\GithubReleases\rnp.$(build.tag).$flavor.zip"
              Write-Host "Packing to $zipFilePath"
              7z -tzip a $zipFilePath .\$root\bin\*

              # Create tar.gz for github release
              $tarFilePath = ".\Releases\GithubReleases\rnp.$(build.tag).$flavor.tar.gz"
              Write-Host "Packing to $tarFilePath"
              tar -cvzf $tarFilePath --directory .\$root\bin *

              # Copy symbols for github release
              $symbolDir = ".\Staging\Symbols\$flavor"
              Write-Host "Copying symbol to $symbolDir"
              New-Item -ItemType Directory -Path $symbolDir
              Copy-Item -Path .\$root\symbols\* $symbolDir -Verbose -Force

              # Generate nuget package
              $nugetProjectRoot = ".\Staging\NugetPackages\$flavor"
              Write-Host "Creating nuget package under $nugetProjectRoot"
              New-Item -ItemType Directory -Path "$nugetProjectRoot" | Out-Null
              Copy-Item -Path .\$root\bin\* $nugetProjectRoot -Verbose -Force
              EvaluateTemplateFile ".\Build.Build.linuxx64\templates\nuget_packages\rnp_nupkg.csproj" "$nugetProjectRoot\rnp_nupkg.csproj"
              dotnet pack $nugetProjectRoot\rnp_nupkg.csproj -o .\Releases\NugetPackages
          }

          # Pack symbols for github release
          $symbolsZipFilePath = ".\Releases\GithubReleases\rnp.$(build.tag).symbols.zip"
          Write-Host "Pack all symbols to $symbolsZipFilePath"
          7z -tzip a $symbolsZipFilePath .\Staging\Symbols\*

          # Crate.io
          Write-Host "Pack source as crate to .\Releases\Crate.io"
          Copy-Item -Path .\Build.Build.linuxx64\crate\* .\Releases\Crate.io -Verbose -Force

          # Chocolatey
          $fileHashs = [pscustomobject]@{
              "ZipX86" = (Get-FileHash ".\Releases\GithubReleases\rnp.$(build.tag).windows.x86.zip" -Algorithm SHA256).Hash;
              "ZipX64" = (Get-FileHash ".\Releases\GithubReleases\rnp.$(build.tag).windows.x64.zip" -Algorithm SHA256).Hash;
              "BinX86" = (Get-FileHash ".\Build.Build.windowsx86\bin\rnp.exe" -Algorithm SHA256).Hash;
              "BinX64" = (Get-FileHash ".\Build.Build.windowsx64\bin\rnp.exe" -Algorithm SHA256).Hash;
          }
          Write-Host "File hash: $fileHashs"
          EvaluateTemplateFileWithFileHash ".\Build.Build.linuxx64\chocolatey\rnp.nuspec" ".\Staging\Chocolatey\rnp.nuspec" $fileHashs
          EvaluateTemplateFileWithFileHash ".\Build.Build.linuxx64\chocolatey\tools\chocolateyInstall.ps1" ".\Staging\Chocolatey\tools\chocolateyInstall.ps1" $fileHashs
          EvaluateTemplateFileWithFileHash ".\Build.Build.linuxx64\chocolatey\tools\VERIFICATION.txt" ".\Staging\Chocolatey\tools\VERIFICATION.txt" $fileHashs
          EvaluateTemplateFileWithFileHash ".\Build.Build.linuxx64\chocolatey\tools\LICENSE.txt" ".\Staging\Chocolatey\tools\LICENSE.txt" $fileHashs
          choco pack ".\Staging\Chocolatey\rnp.nuspec" --outputdirectory ".\Releases\Chocolatey\"
        workingDirectory: '$(System.DefaultWorkingDirectory)/r12f.rnp'
        displayName: 'Generate all packages'

      - task: CopyFiles@2
        displayName: Copy packages to staging folder
        inputs:
          sourceFolder: '$(System.DefaultWorkingDirectory)/r12f.rnp/Releases'
          targetFolder: '$(Build.ArtifactStagingDirectory)/Releases'

      - task: PublishPipelineArtifact@1
        displayName: Publish pipeline artifact
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)'
