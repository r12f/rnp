##############################################
# Environment variables
#

# Environment scripts will be run after global environment variables get defined.
# However, this has to be put in the beginning of the toml file, otherwise it won't run at all.
env_scripts = [
'''
#!@duckscript
echo "Setting environment variables ..."
git_branch = set "${CARGO_MAKE_GIT_BRANCH}"
git_branch = replace ${git_branch} "/" "_"
set_env BUILD_BRANCH ${git_branch}
set_env BUILD_TAG "${BUILD_VERSION}.${git_branch}"
'''
]

[env]
# Directories
BUILD_CONFIG = { source = "${PROFILE_NAME}", default_value = "debug", mapping = {"production" = "release" } }
BUILD_DIR = "target/${CARGO_MAKE_RUST_TARGET_TRIPLE}/${BUILD_CONFIG}"
PUBLISH_DIR = "./publish/${CARGO_MAKE_RUST_TARGET_TRIPLE}"
PACKAGE_DIR = "${PUBLISH_DIR}/packages"

# Build settings
GCC_XCOMPILER_ID = { source = "${CARGO_MAKE_RUST_TARGET_TRIPLE}", default_value = "", mapping = {"i686-unknown-linux-gnu" = "x86_64-linux-gnu", "arm-unknown-linux-gnueabi" = "arm-linux-gnueabi", "aarch64-unknown-linux-gnu" = "aarch64-linux-gnu" } }
BUILD_ARCH = { source = "${CARGO_MAKE_RUST_TARGET_ARCH}", default_value = "${CARGO_MAKE_RUST_TARGET_ARCH}", mapping = {"x86_64" = "x64"} }
BUILD_FLAVOR = "${CARGO_MAKE_RUST_TARGET_OS}.${BUILD_ARCH}"
BUILD_VERSION = "${CARGO_MAKE_CRATE_VERSION}"
BUILD_TARGET = "${CARGO_MAKE_RUST_TARGET_TRIPLE}"
RNP_FILE_NAME = { source = "${CARGO_MAKE_RUST_TARGET_OS}", default_value = "rnp", mapping = {"windows" = "rnp.exe" } }

# Sign settings (Use RNP_SIGNING_URL as enablement key.)
RNP_SIGNING_URL = { value = "${RNP_SIGNING_URL}", condition = { env_set = ["RNP_SIGNING_URL"] } }
RNP_SIGNING_VAULT_URL = { value = "", condition = { env_not_set = ["RNP_SIGNING_VAULT_URL"] } }
RNP_SIGNING_CLIENT_ID = { value = "", condition = { env_not_set = ["RNP_SIGNING_CLIENT_ID"] } }
RNP_SIGNING_CLIENT_SECRET = { value = "", condition = { env_not_set = ["RNP_SIGNING_CLIENT_SECRET"] } }
RNP_SIGNING_CERT_NAME = { value = "", condition = { env_not_set = ["RNP_SIGNING_CERT_NAME"] } }

##############################################
# Init development environment
#
[tasks.init-dev-env]
description = "Init development environment."
linux_alias = "init-dev-env-linux"
mac_alias = "init-dev-env-mac"

[tasks.init-dev-env-linux]
description = "Init development environment on linux."
script_runner="bash"
script = '''
# "sudo" needs to be added within this script, since running "sudo cargo" might results in cargo not found error.
# Add dotnet source and key
wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb

# Add https support to apt and sync apt repo
sudo apt update
sudo apt install -y apt-transport-https
sudo apt update

# Install GCC and required libs/tools
sudo apt install -y build-essential libssl-dev

# Install dotnet SDK
sudo apt install -y dotnet-sdk-5.0
'''

[tasks.init-dev-env-mac]
description = "Init development environment on macos."
script_runner="bash"
script = '''
# Install binutils for objcopy
sudo brew install binutils
'''

##############################################
# Build
#
[tasks.build]
description = "Build the program."
clear = true
dependencies = ["format", "cargo-build", "make-symbol", "sign"]

# Format the code in dev profile.
[tasks.format]
description = "Use rustfmt to format the code."
condition = { profiles = ["development"] }
install_crate = "rustfmt"
command = "cargo"
args = ["fmt", "--", "--emit=files"]

# Cargo build
[tasks.cargo-build]
description = "Run cargo build."
run_task = [
    { name = "cargo-build-dev", condition = { profiles = ["development"] } },
    { name = "cargo-build-release", condition = { profiles = ["production"] } },
]

[tasks.cargo-build-dev]
description = "Run cargo build with dev profile."
command = "cargo"
args = ["build", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

[tasks.cargo-build-release]
description = "Run cargo build with release profile."
command = "cargo"
args = ["build", "--release", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

# Make symbols
[tasks.make-symbol]
windows_alias = "make-symbol-win"
linux_alias = "make-symbol-linux"
mac_alias = "make-symbol-mac"

[tasks.make-symbol-win]
script_runner = "@duckscript"
script = '''
echo "Windows builds generates PDB by default, so nothing to generate here."
'''

[tasks.make-symbol-linux]
script_runner="bash"
script = '''
GCC_PREFIX=""
if [[ "${GCC_XCOMPILER_ID}" -ne "" ]]; then GCC_PREFIX="${GCC_XCOMPILER_ID}-"; fi

echo "Removing existing symbol file: ${BUILD_DIR}/rnp.debug"
rm -f ${BUILD_DIR}/rnp.debug

echo "Generating new symbol file: ${BUILD_DIR}/rnp.debug"
${GCC_PREFIX}objcopy --only-keep-debug ${BUILD_DIR}/rnp ${BUILD_DIR}/rnp.debug
${GCC_PREFIX}strip --strip-debug --strip-unneeded -p ${BUILD_DIR}/rnp
${GCC_PREFIX}objcopy --add-gnu-debuglink=${BUILD_DIR}/rnp.debug ${BUILD_DIR}/rnp
'''

[tasks.make-symbol-mac]
script = '''
echo "Removing existing symbol file: ${BUILD_DIR}/rnp.debug"
rm -f ${BUILD_DIR}/rnp.debug

echo "Generating new symbol file: ${BUILD_DIR}/rnp.debug"
/usr/local/opt/binutils/bin/gobjcopy --only-keep-debug ${BUILD_DIR}/rnp ${BUILD_DIR}/rnp.debug
strip -S ${BUILD_DIR}/rnp
/usr/local/opt/binutils/bin/gobjcopy --add-gnu-debuglink=${BUILD_DIR}/rnp.debug ${BUILD_DIR}/rnp
'''

# Sign
[tasks.sign]
description = "Run AzureSignTool to sign the binaries."
condition = { platforms = ["windows"], env_set = [ "RNP_SIGNING_URL" ] }
command = "AzureSignTool"
args = ["sign", "-du", "${RNP_SIGNING_URL}", "-kvu", "${RNP_SIGNING_VAULT_URL}", "-kvi", "${RNP_SIGNING_CLIENT_ID}", "-kvs", "${RNP_SIGNING_CLIENT_SECRET}", "-kvc", "${RNP_SIGNING_CERT_NAME}", "-v", "${BUILD_DIR}/rnp.exe"]

# Pack packages for each platform
[tasks.pack]
description = "Pack binaries into packages."
run_task = [
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-zip", "pack-nuget", "pack-msix"], condition = { platforms = ["windows"] } },
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-tar", "pack-nuget", "pack-deb"], condition = { platforms = ["linux"] } },
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-tar", "pack-nuget"], condition = { platforms = ["macos"] } },
]

[tasks.pack-prepare]
description = "Prepare environments for pack."
script_runner = "@duckscript"
script = '''
echo "Removing publish directory: ${PUBLISH_DIR}"
rm -r ${PUBLISH_DIR}

if not is_dir ${PUBLISH_DIR}
    echo "Creating publish directory: ${PUBLISH_DIR}"
    mkdir ${PUBLISH_DIR}
end

if not is_dir ${PACKAGE_DIR}
    echo "Creating package directory: ${PACKAGE_DIR}"
    mkdir ${PACKAGE_DIR}
end
'''

[tasks.pack-binaries]
description = "Pack binaries."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/bin"

if not is_dir ${OUT_DIR}
    echo "Creating output directory: ${OUT_DIR}"
    mkdir ${OUT_DIR}
end

echo "Copying binaries from build output: ${BUILD_DIR}"
cp ${BUILD_DIR}/${RNP_FILE_NAME} ${OUT_DIR}/${RNP_FILE_NAME}

echo "Copying key documents from source code"
cp README.md ${OUT_DIR}/README.md
cp LICENSE.txt ${OUT_DIR}/LICENSE.txt
'''

[tasks.pack-symbols]
description = "Pack symbol files."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/symbols"

if not is_dir ${OUT_DIR}
    echo "Creating output directory: ${OUT_DIR}"
    mkdir ${OUT_DIR}
end

if is_path_exists ${BUILD_DIR}/rnp.pdb
    cp ${BUILD_DIR}/rnp.pdb ${OUT_DIR}/rnp.pdb
end

if is_path_exists ${BUILD_DIR}/rnp.debug
    cp ${BUILD_DIR}/rnp.debug ${OUT_DIR}/rnp.debug
end
'''

[tasks.pack-zip]
description = "Pack zip package."
script_runner = "@duckscript"
script = '''
ZIP_FILE_PATH = set "${PACKAGE_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.zip"
echo "Pack binaries to ${ZIP_FILE_PATH}"
exec 7z -tzip a ${ZIP_FILE_PATH} ./${PUBLISH_DIR}/bin/*
'''

[tasks.pack-tar]
description = "Pack tar package."
script_runner = "bash"
script = '''
TAR_FILE_PATH="${PACKAGE_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.tar.gz"
echo "Pack binaries under ${PUBLISH_DIR}/bin/* to ${TAR_FILE_PATH}"
tar --transform "s/.*\///g" -zcvf ${TAR_FILE_PATH} ${PUBLISH_DIR}/bin/*
'''

[tasks.pack-nuget]
description = "Pack nuget package."
script_runner = "@duckscript"
script = '''
!include_files ./build/pack/pack_utils.ds

INT_DIR = set "${BUILD_DIR}/nuget"

echo "Removing intermediate directory: ${INT_DIR}"
rm -r ${INT_DIR}

echo "Copying bin output as intermediate directory: ${INT_DIR}"
cp ${PUBLISH_DIR}/bin ${INT_DIR}
eval_build_template_file "./build/templates/nuget_packages/rnp_nupkg.csproj" ${INT_DIR}/rnp_nupkg.csproj

OUT_DIR = set "${PUBLISH_DIR}/nuget"

if not is_dir ${OUT_DIR}
    echo "Creating output directory: ${OUT_DIR}"
    mkdir ${OUT_DIR}
end

exec dotnet pack ${INT_DIR}/rnp_nupkg.csproj -o ${OUT_DIR}
'''

[tasks.pack-msix]
description = "Pack msix package."
script_runner = "@duckscript"
script = '''
!include_files ./build/pack/pack_utils.ds

INT_DIR = set "${BUILD_DIR}/msix"

echo "Removing intermediate directory: ${INT_DIR}"
rm -r ${INT_DIR}

echo "Copying bin output as intermediate directory: ${INT_DIR}"
cp ${PUBLISH_DIR}/bin ${INT_DIR}
cp ./assets ${INT_DIR}
eval_build_template_file "./build/templates/msix/appxmanifest.xml" ${INT_DIR}/appxmanifest.xml
eval_build_template_file "./build/templates/msix/appxmappings-make.txt" ${INT_DIR}/appxmappings.txt

OUT_DIR = set "${PUBLISH_DIR}/msix"

if not is_dir ${OUT_DIR}
    echo "Creating output directory: ${OUT_DIR}"
    mkdir ${OUT_DIR}
end

exec "C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/makeappx.exe" pack /m "${INT_DIR}/appxmanifest.xml" /f "${INT_DIR}/appxmappings.txt" /p "${OUT_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.msix"
'''

[tasks.pack-deb]
description = "Pack deb package."
script_runner = "@duckscript"
script = '''
!include_files ./build/pack/pack_utils.ds

proc_version = readfile "/proc/version"
echo "Read proc version for detecting WSL: ${proc_version}"
wsl_identity = indexof ${proc_version} "microsoft"
if not is_empty ${wsl_identity}
    echo "Found we are running in WSL environment. Building DEBIAN package is not supported in WSL, due to linux chmod is not fully supported by NTFS."
    echo "Skipping build task: pack-deb."
    exit 0
end

INT_DIR = set "${BUILD_DIR}/deb"

echo "Removing intermediate directory: ${INT_DIR}"
rm -r ${INT_DIR}

DEB_ARCH = set ${BUILD_ARCH}
if equals ${DEB_ARCH} "x64"
    DEB_ARCH = set "amd64"
end

DEB_PACKAGE_NAME = set "rnp_${BUILD_VERSION}-1_${DEB_ARCH}"
echo "Creating deb package: ${DEB_PACKAGE_NAME}"

INT_DEB_BIN_DIR = set "${INT_DIR}/${DEB_PACKAGE_NAME}/usr/local/bin"
echo "Creating intermediate directory for binary: ${INT_DEB_BIN_DIR}"
mkdir ${INT_DEB_BIN_DIR}

echo "Copy binaries to deb package: ${INT_DEB_BIN_DIR}"
cp ${PUBLISH_DIR}/bin/rnp ${INT_DEB_BIN_DIR}/rnp

INT_DEB_CONTROL_DIR = set "${INT_DIR}/${DEB_PACKAGE_NAME}/DEBIAN"
echo "Creating intermediate directory for debain control: ${INT_DEB_CONTROL_DIR}"
mkdir ${INT_DEB_CONTROL_DIR}

eval_build_template_file "./build/templates/debian/control" ${INT_DEB_CONTROL_DIR}/control

echo "Generating deb package: ${INT_DIR}/${DEB_PACKAGE_NAME}"
exec dpkg-deb --build --root-owner-group ${INT_DIR}/${DEB_PACKAGE_NAME}

OUT_DIR = set "${PUBLISH_DIR}/deb"

if not is_dir ${OUT_DIR}
    echo "Creating output directory: ${OUT_DIR}"
    mkdir ${OUT_DIR}
end

echo "Copying deb package to output folder: File = ${INT_DIR}/${DEB_PACKAGE_NAME}.deb, Target = ${OUT_DIR}"
cp ${INT_DIR}/${DEB_PACKAGE_NAME}.deb ${OUT_DIR}/${DEB_PACKAGE_NAME}.deb
'''

##############################################
# Test
#
[tasks.test]
description = "Run all tests."
clear = true
run_task = [
    { name = "test-dev", condition = { profiles = ["development"] } },
    { name = "test-release", condition = { profiles = ["production"] } },
]

[tasks.test-dev]
description = "Run all tests with dev profile."
command = "cargo"
args = ["test", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

[tasks.test-release]
description = "Run all tests with release profile."
command = "cargo"
args = ["test", "--release", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]
