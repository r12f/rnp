##############################################
# Environment variables
#

# Environment scripts will be run after global environment variables get defined.
# However, this has to be put in the beginning of the toml file, otherwise it won't run at all.
env_scripts = [
'''
#!@duckscript
echo "Setting environment variables ..."
git_branch = set "${CARGO_MAKE_GIT_BRANCH}"
git_branch = replace ${git_branch} " " "_"
git_branch = replace ${git_branch} "/" "_"
set_env BUILD_BRANCH ${git_branch}
set_env BUILD_TAG "${BUILD_VERSION}.${git_branch}"
'''
]

[env]
# Directories
BUILD_CONFIG = { source = "${CARGO_MAKE_PROFILE}", default_value = "debug", mapping = {"production" = "release" } }
BUILD_DIR = "${CARGO_MAKE_WORKING_DIRECTORY}/target/${CARGO_MAKE_RUST_TARGET_TRIPLE}/${BUILD_CONFIG}"
PUBLISH_DIR = "${CARGO_MAKE_WORKING_DIRECTORY}/publish/${CARGO_MAKE_RUST_TARGET_TRIPLE}"

# Build settings
GCC_XCOMPILER_ID = { source = "${CARGO_MAKE_RUST_TARGET_TRIPLE}", default_value = "", mapping = {"i686-unknown-linux-gnu" = "x86_64-linux-gnu", "arm-unknown-linux-gnueabi" = "arm-linux-gnueabi", "aarch64-unknown-linux-gnu" = "aarch64-linux-gnu" } }
BUILD_ARCH = { source = "${CARGO_MAKE_RUST_TARGET_ARCH}", default_value = "${CARGO_MAKE_RUST_TARGET_ARCH}", mapping = {"x86_64" = "x64"} }
BUILD_FLAVOR = "${CARGO_MAKE_RUST_TARGET_OS}.${BUILD_ARCH}"
BUILD_VERSION = "${CARGO_MAKE_CRATE_VERSION}"
BUILD_TARGET = "${CARGO_MAKE_RUST_TARGET_TRIPLE}"
RNP_FILE_NAME = { source = "${CARGO_MAKE_RUST_TARGET_OS}", default_value = "rnp", mapping = { "windows" = "rnp.exe" } }

# Sign settings (Use RNP_SIGNING_URL as enablement key.)
RNP_SIGNING_URL = { value = "${RNP_SIGNING_URL}", condition = { env_set = ["RNP_SIGNING_URL"] } }
RNP_SIGNING_VAULT_URL = { value = "", condition = { env_not_set = ["RNP_SIGNING_VAULT_URL"] } }
RNP_SIGNING_CLIENT_ID = { value = "", condition = { env_not_set = ["RNP_SIGNING_CLIENT_ID"] } }
RNP_SIGNING_CLIENT_SECRET = { value = "", condition = { env_not_set = ["RNP_SIGNING_CLIENT_SECRET"] } }
RNP_SIGNING_CERT_NAME = { value = "", condition = { env_not_set = ["RNP_SIGNING_CERT_NAME"] } }

# Debug settings
RUST_BACKTRACE = "full" # Enable full stack trace all the time.

# Tools
GNU_TAR = { source = "${CARGO_MAKE_RUST_TARGET_OS}", default_value = "tar", mapping = { "mac" = "gtar" } }

##############################################
# Init development environment
#

# Install build tools
[tasks.install-build-tools]
description = "Install build tools."
windows_alias = "install-build-tools-windows"
linux_alias = "install-build-tools-linux"
mac_alias = "install-build-tools-mac"

[tasks.install-build-tools-windows]
description = "Install build tools on windows."
script = '''
@echo off

:: Install toolchains for cross builds
echo Installing rust target: %CARGO_MAKE_RUST_TARGET_TRIPLE%.
rustup target install %CARGO_MAKE_RUST_TARGET_TRIPLE%

:: Install AzureSignTool
:: dotnet tool update is now the better (or more expected) way to install the tools. For details, please see the PR and issue below:
:: - https://github.com/dotnet/cli/pull/10205
:: - https://github.com/dotnet/sdk/issues/9500
echo Installing AzureSignTool.
dotnet tool update --global azuresigntool
'''

[tasks.install-build-tools-linux]
description = "Install build tools on linux."
script_runner="bash"
script = '''
# "sudo" needs to be added within this script, since running "sudo cargo" might results in cargo not found error.
sudo apt update

# Install GCC and required libs/tools
echo "Installing build tools and required libs."
sudo apt install -y build-essential libssl-dev

case "${CARGO_MAKE_RUST_TARGET_TRIPLE}" in
    "i686-unknown-linux-gnu")
        # For building x86 binary, we are using gcc-multilib.
        # This package is conflicting with other gcc-* packages, but we don't know any better package to use.
        # But sadly, this package is lacking of tools that we need to build ARM/ARM64, so we can only pick 1 to use - either support x86 or ARM/ARM64.
        sudo apt install -y gcc-multilib
        ;;
    "arm-unknown-linux-gnueabi")
        sudo apt install -y gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi
        ;;
    "aarch64-unknown-linux-gnu")
        sudo apt install -y gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu
        ;;
esac

# Install toolchains for cross builds
echo "Installing rust target: ${CARGO_MAKE_RUST_TARGET_TRIPLE}"
rustup target install ${CARGO_MAKE_RUST_TARGET_TRIPLE}
'''

[tasks.install-build-tools-mac]
description = "Install build tools on mac."
script_runner="bash"
script = '''
echo "Installing build tools: binutils"
brew install binutils
'''

# Install scripts tools
[tasks.install-pack-tools]
description = "Install pack tools."
linux_alias = "install-pack-tools-linux"
mac_alias = "install-pack-tools-mac"

[tasks.install-pack-tools-linux]
description = "Install pack tools on linux."
script_runner="bash"
script = '''
# "sudo" needs to be added within this script, since running "sudo cargo" might results in cargo not found error.
# Add dotnet source and key
wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb

# Add https support to apt and sync apt repo
sudo apt update
sudo apt install -y apt-transport-https
sudo apt update

# Install dotnet SDK
sudo apt install -y dotnet-sdk-5.0

# Install required misc tools
sudo apt install -y p7zip-full
'''

[tasks.install-pack-tools-mac]
description = "Install pack tools on mac."
script_runner="bash"
script = '''
echo "Installing pack tools: gnu-tar"
brew install gnu-tar
'''

##############################################
# Build
#
[tasks.build]
description = "Build the program."
clear = true
dependencies = ["format", "cargo-build", "make-symbol", "sign-binary"]

# Format the code in dev profile.
[tasks.format]
description = "Use rustfmt to format the code."
condition = { profiles = ["development"] }
install_crate = "rustfmt"
command = "cargo"
args = ["fmt", "--", "--emit=files"]

# Cargo build
[tasks.cargo-build]
description = "Run cargo build."
run_task = [
    { name = "cargo-build-dev", condition = { profiles = ["development"] } },
    { name = "cargo-build-release", condition = { profiles = ["production"] } },
]

[tasks.cargo-build-dev]
description = "Run cargo build with dev profile."
command = "cargo"
args = ["build", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

[tasks.cargo-build-release]
description = "Run cargo build with release profile."
command = "cargo"
args = ["build", "--release", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

# Make symbols
[tasks.make-symbol]
windows_alias = "make-symbol-win"
linux_alias = "make-symbol-linux"
mac_alias = "make-symbol-mac"

[tasks.make-symbol-win]
script_runner = "@duckscript"
script = '''
echo "Windows builds generates PDB by default, so nothing to generate here."
'''

[tasks.make-symbol-linux]
script_runner="bash"
script = '''
GCC_PREFIX=""
if [[ "${GCC_XCOMPILER_ID}" -ne "" ]]; then GCC_PREFIX="${GCC_XCOMPILER_ID}-"; fi

echo "Removing existing symbol file: ${BUILD_DIR}/rnp.debug"
rm -f ${BUILD_DIR}/rnp.debug

echo "Generating new symbol file: ${BUILD_DIR}/rnp.debug"
${GCC_PREFIX}objcopy --only-keep-debug "${BUILD_DIR}/rnp" "${BUILD_DIR}/rnp.debug"
${GCC_PREFIX}strip --strip-debug --strip-unneeded -p "${BUILD_DIR}/rnp"
${GCC_PREFIX}objcopy --add-gnu-debuglink="${BUILD_DIR}/rnp.debug" "${BUILD_DIR}/rnp"
'''

[tasks.make-symbol-mac]
script = '''
echo "Removing existing symbol file: ${BUILD_DIR}/rnp.debug"
rm -f ${BUILD_DIR}/rnp.debug

echo "Generating new symbol file: ${BUILD_DIR}/rnp.debug"
/usr/local/opt/binutils/bin/gobjcopy --only-keep-debug "${BUILD_DIR}/rnp" "${BUILD_DIR}/rnp.debug"
strip -S "${BUILD_DIR}/rnp"
/usr/local/opt/binutils/bin/gobjcopy --add-gnu-debuglink="${BUILD_DIR}/rnp.debug" "${BUILD_DIR}/rnp"
'''

# Sign
[tasks.sign-binary]
description = "Run AzureSignTool to sign the binaries."
condition = { platforms = ["windows"], env_set = [ "RNP_SIGNING_URL" ] }
command = "AzureSignTool"
args = ["sign", "-du", "${RNP_SIGNING_URL}", "-kvu", "${RNP_SIGNING_VAULT_URL}", "-kvi", "${RNP_SIGNING_CLIENT_ID}", "-kvs", "${RNP_SIGNING_CLIENT_SECRET}", "-kvc", "${RNP_SIGNING_CERT_NAME}", "-v", "${BUILD_DIR}/rnp.exe"]

##############################################
# Pack packages
#
[tasks.pack]
description = "Pack binaries into packages."
run_task = [
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-zip", "pack-nuget", "pack-msix", "pack-choco", "pack-scripts", "sign-packages"], condition = { platforms = ["windows"] } },
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-tar", "pack-nuget", "pack-deb", "pack-source"], condition = { platforms = ["linux"] } },
    { name = ["pack-prepare", "pack-binaries", "pack-symbols", "pack-tar", "pack-nuget", "pack-brew"], condition = { platforms = ["mac"] } },
]

[tasks.pack-prepare]
description = "Prepare environments for pack."
script_runner = "@duckscript"
script = '''
if is_dir ${PUBLISH_DIR}
    echo "Removing publish directory: ${PUBLISH_DIR}"
    rm -r ${PUBLISH_DIR}
end

echo "Creating publish directory: ${PUBLISH_DIR}"
mkdir ${PUBLISH_DIR}
'''

[tasks.pack-binaries]
description = "Pack binaries."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/bin"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

echo "Copying binaries from build output: ${BUILD_DIR}"
cp ${BUILD_DIR}/${RNP_FILE_NAME} ${OUT_DIR}/${RNP_FILE_NAME}

echo "Copying key documents from source code"
cp README.md ${OUT_DIR}/README.md
cp LICENSE.txt ${OUT_DIR}/LICENSE.txt
'''

[tasks.pack-symbols]
description = "Pack symbol files."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/symbols"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

if is_path_exists ${BUILD_DIR}/rnp.pdb
    cp ${BUILD_DIR}/rnp.pdb ${OUT_DIR}/rnp.pdb
end

if is_path_exists ${BUILD_DIR}/rnp.debug
    cp ${BUILD_DIR}/rnp.debug ${OUT_DIR}/rnp.debug
end
'''

[tasks.pack-source]
description = "Pack source package."
script_runner = "bash"
script = '''
INT_DIR="${BUILD_DIR}/source"

# Clean up
if [ -d "${INT_DIR}" ]; then
    echo "Removing intermediate directory: ${INT_DIR}"
    rm -rf "${INT_DIR}"
fi
echo "Creating intermediate directory: ${INT_DIR}"
mkdir "${INT_DIR}"

# Prepare the source package
echo "Copying source code to ${INT_DIR}"
cp -r `ls -a | grep -E -v '^(target|publish|log\..*|\.|\..)$'` "${INT_DIR}/"
cd "${INT_DIR}" && git clean -xfd && cd -

# Create source packages
OUT_DIR="${PUBLISH_DIR}/source"
if [ -d "${OUT_DIR}" ]; then
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -rf "${OUT_DIR}"
fi
echo "Creating new output directory: ${OUT_DIR}"
mkdir "${OUT_DIR}"

CRATE_FILE_PATH="${OUT_DIR}/rnp.crate.7z"
echo "Pack source code for crate publishing: ${CRATE_FILE_PATH}"
cd "${INT_DIR}" && 7z -t7z a "${CRATE_FILE_PATH}" . && cd -

echo "Cleanup git info in intermediate directory for source code publishing: ${INT_DIR}"
rm -rf "${INT_DIR}/.git"

ZIP_FILE_PATH="${OUT_DIR}/rnp.source.${BUILD_TAG}.zip"
echo "Pack source code into zip: ${ZIP_FILE_PATH}"
cd "${INT_DIR}" && 7z -tzip a "${ZIP_FILE_PATH}" . && cd -

TAR_FILE_PATH="${OUT_DIR}/rnp.source.${BUILD_TAG}.tar.gz"
echo "Pack source code into tar: ${TAR_FILE_PATH}"
cd "${INT_DIR}" && ${GNU_TAR} --transform "s/^\.\///g" -zcvf "${TAR_FILE_PATH}" . && cd -
'''

[tasks.pack-zip]
description = "Pack zip package."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/zipped"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

ZIP_FILE_PATH = set "${OUT_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.zip"
echo "Pack binaries ${PUBLISH_DIR}/bin/* to ${ZIP_FILE_PATH}"
exec 7z -tzip a ${ZIP_FILE_PATH} ${PUBLISH_DIR}/bin/*
'''

[tasks.pack-tar]
description = "Pack tar package."
script_runner = "bash"
script = '''
OUT_DIR="${PUBLISH_DIR}/zipped"
if [ -d "${OUT_DIR}" ]; then
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -rf "${OUT_DIR}"
fi
echo "Creating new output directory: ${OUT_DIR}"
mkdir "${OUT_DIR}"

TAR_FILE_PATH="${OUT_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.tar.gz"
echo "Pack binaries ${PUBLISH_DIR}/bin/* to ${TAR_FILE_PATH}"
${GNU_TAR} --transform "s/.*\///g" -zcvf "${TAR_FILE_PATH}" ${PUBLISH_DIR}/bin/*
'''

[tasks.pack-nuget]
description = "Pack nuget package."
script_runner = "@duckscript"
script = '''
!include_files ./build/scripts/pack_utils.ds

INT_DIR = set "${BUILD_DIR}/nuget"

# Clean up
if is_dir ${INT_DIR}
    echo "Removing intermediate directory: ${INT_DIR}"
    rm -r ${INT_DIR}
end

# Prepare to build package
echo "Copying bin output as intermediate directory: ${INT_DIR}"
cp ${PUBLISH_DIR}/bin ${INT_DIR}
eval_build_template_file "./build/templates/nuget_packages/rnp_nupkg.csproj" ${INT_DIR}/rnp_nupkg.csproj

# Build to output folder
OUT_DIR = set "${PUBLISH_DIR}/nuget"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

echo "Build package from ${INT_DIR} to ${OUT_DIR}"
exec dotnet pack ${INT_DIR}/rnp_nupkg.csproj -o ${OUT_DIR}
'''

[tasks.pack-msix]
description = "Pack msix package."
script_runner = "@duckscript"
script = '''
!include_files ./build/scripts/pack_utils.ds

INT_DIR = set "${BUILD_DIR}/msix"

# Cleanup
if is_dir ${INT_DIR}
    echo "Removing intermediate directory: ${INT_DIR}"
    rm -r ${INT_DIR}
end

# Prepare to build package
echo "Copying bin output as intermediate directory: ${INT_DIR}"
cp ${PUBLISH_DIR}/bin ${INT_DIR}
cp ./assets ${INT_DIR}
eval_build_template_file "./build/templates/msix/appxmanifest.xml" ${INT_DIR}/appxmanifest.xml
eval_build_template_file "./build/templates/msix/appxmappings-make.txt" ${INT_DIR}/appxmappings.txt

# Build to output folder
OUT_DIR = set "${PUBLISH_DIR}/msix"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

PACKAGE_PATH = set "${OUT_DIR}/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.msix"
echo "Build package from ${INT_DIR} to ${PACKAGE_PATH}"
exec "C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/makeappx.exe" pack /m "${INT_DIR}/appxmanifest.xml" /f "${INT_DIR}/appxmappings.txt" /p ${PACKAGE_PATH}
'''

[tasks.pack-deb]
description = "Pack deb package."
script_runner = "@duckscript"
script = '''
!include_files ./build/scripts/pack_utils.ds

proc_version = readfile "/proc/version"
echo "Read proc version for detecting WSL: ${proc_version}"
wsl_identity = indexof ${proc_version} "microsoft"
if not is_empty ${wsl_identity}
    echo "Found we are running in WSL environment. Building DEBIAN package is not supported in WSL, due to linux chmod is not fully supported by NTFS."
    echo "Skipping build task: pack-deb."
    exit 0
end

INT_DIR = set "${BUILD_DIR}/deb"

# Clean up
if is_dir ${INT_DIR}
    echo "Removing intermediate directory: ${INT_DIR}"
    rm -r ${INT_DIR}
end

# Build deb package
DEB_ARCH = set ${BUILD_ARCH}
if equals ${DEB_ARCH} "x64"
    DEB_ARCH = set "amd64"
end

DEB_PACKAGE_NAME = set "rnp_${BUILD_VERSION}-1_${DEB_ARCH}"
echo "Creating deb package: ${DEB_PACKAGE_NAME}"

INT_DEB_BIN_DIR = set "${INT_DIR}/${DEB_PACKAGE_NAME}/usr/local/bin"
echo "Creating intermediate directory for binary: ${INT_DEB_BIN_DIR}"
mkdir ${INT_DEB_BIN_DIR}

echo "Copy binaries to deb package: ${INT_DEB_BIN_DIR}"
cp ${PUBLISH_DIR}/bin/rnp ${INT_DEB_BIN_DIR}/rnp

INT_DEB_CONTROL_DIR = set "${INT_DIR}/${DEB_PACKAGE_NAME}/DEBIAN"
echo "Creating intermediate directory for debain control: ${INT_DEB_CONTROL_DIR}"
mkdir ${INT_DEB_CONTROL_DIR}

eval_build_template_file "./build/templates/debian/control" ${INT_DEB_CONTROL_DIR}/control

echo "Generating deb package: ${INT_DIR}/${DEB_PACKAGE_NAME}"
exec dpkg-deb --build --root-owner-group ${INT_DIR}/${DEB_PACKAGE_NAME}

# Publish to output folder
OUT_DIR = set "${PUBLISH_DIR}/deb"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

echo "Copying deb package to output folder: File = ${INT_DIR}/${DEB_PACKAGE_NAME}.deb, Target = ${OUT_DIR}"
cp ${INT_DIR}/${DEB_PACKAGE_NAME}.deb ${OUT_DIR}/${DEB_PACKAGE_NAME}.deb
'''

[tasks.pack-choco]
description = "Pack chocolatecy package source."
script_runner = "@duckscript"
script = '''
!include_files ./build/scripts/pack_utils.ds

# Build to output folder
OUT_DIR = set "${PUBLISH_DIR}/choco"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}
mkdir ${OUT_DIR}/tools

TEMPLATE_DIR = set "./build/templates/chocolatey"
echo "Generating chocolatey package source from ${TEMPLATE_DIR} to ${OUT_DIR}"
eval_build_template_file "${TEMPLATE_DIR}/rnp.nuspec" ${OUT_DIR}/rnp.nuspec
eval_build_template_file "${TEMPLATE_DIR}/tools/chocolateyinstall.ps1" ${OUT_DIR}/tools/chocolateyinstall.ps1
eval_build_template_file "${TEMPLATE_DIR}/tools/LICENSE.txt" ${OUT_DIR}/tools/LICENSE.txt
eval_build_template_file "${TEMPLATE_DIR}/tools/VERIFICATION.txt" ${OUT_DIR}/tools/VERIFICATION.txt
'''

[tasks.pack-brew]
description = "Pack homebrew package source."
script_runner = "@duckscript"
script = '''
!include_files ./build/scripts/pack_utils.ds

# Build to output folder
OUT_DIR = set "${PUBLISH_DIR}/homebrew"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

TEMPLATE_DIR = set "./build/templates/homebrew"
echo "Generating chocolatey package source from ${TEMPLATE_DIR} to ${OUT_DIR}"
eval_build_template_file "${TEMPLATE_DIR}/rnp.rb" ${OUT_DIR}/rnp.rb
'''

[tasks.pack-scripts]
description = "Pack release scripts."
script_runner = "@duckscript"
script = '''
OUT_DIR = set "${PUBLISH_DIR}/scripts"
if is_dir ${OUT_DIR}
    echo "Removing previous output directory: ${OUT_DIR}"
    rm -r ${OUT_DIR}
end
echo "Creating new output directory: ${OUT_DIR}"
mkdir ${OUT_DIR}

RELEASE_SCRIPT_PATH = set "./build/scripts/New-RnpReleasePackages.ps1"
echo "Copying release script from ${RELEASE_SCRIPT_PATH} to ${OUT_DIR}"
cp ${RELEASE_SCRIPT_PATH} "${OUT_DIR}/New-RnpReleasePackages.ps1"
'''

[tasks.sign-packages]
description = "Run AzureSignTool to sign the packages."
condition = { env_set = [ "RNP_SIGNING_URL" ] }
script_runner = "@duckscript"
script = '''
exec AzureSignTool sign -du ${RNP_SIGNING_URL} -kvu ${RNP_SIGNING_VAULT_URL} -kvi ${RNP_SIGNING_CLIENT_ID} -kvs ${RNP_SIGNING_CLIENT_SECRET} -kvc ${RNP_SIGNING_CERT_NAME} -v "${PUBLISH_DIR}/msix/rnp.${BUILD_TAG}.${BUILD_FLAVOR}.msix"
'''

##############################################
# Test
#
[tasks.test]
description = "Run all tests."
clear = true
run_task = [
    { name = "test-dev", condition = { profiles = ["development"] } },
    { name = "test-release", condition = { profiles = ["production"] } },
]

[tasks.test-dev]
description = "Run all tests with dev profile."
command = "cargo"
args = ["test", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

[tasks.test-release]
description = "Run all tests with release profile."
command = "cargo"
args = ["test", "--release", "--target", "${CARGO_MAKE_RUST_TARGET_TRIPLE}"]

##############################################
# CI flow
#
[tasks.ci-flow]
dependencies = [
    "build",
    "test",
    "pack",
]
